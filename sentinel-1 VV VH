/********************************************************
 * 1. 数据加载与基础设置
 ********************************************************/
var bamboo = ee.FeatureCollection("projects/my-project1-477312/assets/Asia_bambusa");
var negative = ee.FeatureCollection("projects/my-project1-477312/assets/nobambusa_china");
var roi = ee.FeatureCollection("projects/my-project1-477312/assets/text1").geometry();

// 锁定 2020 年
var year = 2020;

/********************************************************
 * 2. 基础数据准备（DEM 与 RTC 预处理函数）
 ********************************************************/
var dem = ee.Image('USGS/SRTMGL1_003');
var terrain = ee.Algorithms.Terrain(dem);
var slopeRad  = terrain.select('slope').multiply(Math.PI/180);
var aspectRad = terrain.select('aspect').multiply(Math.PI/180);

// 单景影像 RTC 矫正函数
function applyRTC(img) {
  var vv_linear = ee.Image(10).pow(img.select('VV').divide(10));
  var vh_linear = ee.Image(10).pow(img.select('VH').divide(10));
  var theta_i = img.select('angle').multiply(Math.PI/180);
  var phi_i = ee.Image.constant(0);
  var phi_s = aspectRad;
  var alpha_range = (slopeRad.tan().multiply((phi_i.subtract(phi_s)).cos())).atan();
  
  var gamma0_vv = vv_linear.divide(theta_i.cos());
  var gamma0_vh = vh_linear.divide(theta_i.cos());
  
  var num = (ee.Image.constant(Math.PI/2).subtract(theta_i)).tan();
  var den = (ee.Image.constant(Math.PI/2).subtract(theta_i).add(alpha_range)).tan();
  var ratio = num.divide(den);
  
  var VV_RTC = gamma0_vv.multiply(ratio).rename('VV');
  var VH_RTC = gamma0_vh.multiply(ratio).rename('VH');
  var ratio_band = VV_RTC.divide(VH_RTC).rename('Ratio');
  
  return ee.Image([VV_RTC, VH_RTC, ratio_band])
    .copyProperties(img, ['system:time_start']);
}

/********************************************************
 * 3. 按月合成多波段影像
 ********************************************************/
var months = ee.List.sequence(1, 12);

var monthlyImage = ee.ImageCollection.fromImages(months.map(function(m) {
  var start = ee.Date.fromYMD(year, m, 1);
  var end = start.advance(1, 'month');
  
  var s1_month = ee.ImageCollection('COPERNICUS/S1_GRD')
    .filterBounds(roi)
    .filterDate(start, end)
    .filter(ee.Filter.eq('instrumentMode', 'IW'))
    .filter(ee.Filter.listContains('transmitterReceiverPolarisation','VV'))
    .filter(ee.Filter.listContains('transmitterReceiverPolarisation','VH'))
    .map(applyRTC);
  
  var monthMean = s1_month.mean().clip(roi);
  var monthName = ee.String('_Month_').cat(ee.Number(m).format('%02d'));
  
  return monthMean.rename([
    ee.String('VV').cat(monthName),
    ee.String('VH').cat(monthName),
    ee.String('Ratio').cat(monthName)
  ]);
})).toBands();

/********************************************************
 * 4. 创建缓冲区并进行均值提取 (Reduce Regions)
 ********************************************************/
// 10米缓冲区约覆盖 10x10m 像素及其周边，能有效平滑数据
var bufferRadius = 10; 

// 处理竹林样本
var bamboo_roi = bamboo.filterBounds(roi).map(function(f) {
  return f.buffer(bufferRadius).set('label', 1);
});

// 处理非竹林样本（保留原始 Map 属性）
var nonbamboo_roi = negative.filterBounds(roi).map(function(f) {
  return f.buffer(bufferRadius).set('label', ee.Number(f.get('Map')));
});

// 合并矢量集合
var combinedSamples = bamboo_roi.merge(nonbamboo_roi);

// 使用 reduceRegions 提取缓冲区内的平均值
var training_features = monthlyImage.reduceRegions({
  collection: combinedSamples,
  reducer: ee.Reducer.mean(),
  scale: 10,
  tileScale: 16
});

// 过滤掉因为缓冲区超出影像边缘产生的空值点
var training_cleaned = training_features.filter(ee.Filter.notNull(monthlyImage.bandNames()));

/********************************************************
 * 5. 导出设置
 ********************************************************/
// 获取波段名称，这些名称在 reduceRegions 后会自动作为属性
var bandNames = monthlyImage.bandNames();
var exportProperties = bandNames.add('label');

Export.table.toDrive({
  collection: training_cleaned,
  description: 'Bamboo_Monthly_Buffered_Samples_2020',
  fileNamePrefix: 'Bamboo_Monthly_Buffered_Samples_2020',
  fileFormat: 'CSV',
  selectors: exportProperties.getInfo() 
});

print('月度合成影像波段预览：', bandNames);
print('样本点（含10m缓冲区）提取完成。');
print('样本分布检查：', training_cleaned.aggregate_histogram('label'));
